---
title: "Geospatial Analysis with R"
subtitle: Class 7
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "lucy", "middlebury-fonts", "themes/class7.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, eval=FALSE}
library(stars)
s3url <- glue::glue("/vsis3/activemapper/",
                    "planet/composite_sr_buf_fix/GS/",
                    "tile486317_736815_736967.tif")  # not accessible
p <- read_stars(s3url, proxy = TRUE)
png(here::here("external/slides/figures/ghana_planet_stars.png"), height = 2.9, 
    width = 8, units  = "in", res = 300, bg = "white")
plot(p)
dev.off()
```

---

# Today

- Quiz
- Building blocks of R: data types, functions, etc
- Useful functions
- Indexing and subsetting
- Control structures

---

## The R Ecosystem
### Vectors

```{r, echo=FALSE, fig.align='center', fig.cap='Credit: L. Song'}
knitr::include_graphics("figures/class2_vector.png")
```

---
## Let's create some data

- `vector`
- `matrix`
- `data.frame`
- `list`
---

## Creating a vector
```{r}
v1 <- c(1,2,3,4,5)
v2 <- 6:10
print(v1)
print(v2)
```

---
## Combining vectors

```{r}
v1 <- c(1,2,3,4,5)
v2 <- 6:10
v3 <- c(v1, v2)
print(v3)
print(class(v3))
```
---
## Combining vectors
What happens when you combine data types in a vector?

```{r}
v4 <- c(v1, "test")
print(v4)
print(class(v4))
```
---
## Vectorized operations
```{r}
v1 <- 1:9
print(v1)
print(v1 + 5) ## addition applied to each element in vector
print(v1 * 3) ## multiplication applied to each element in vector
```

---
## Accessing elements in vector
```{r}
v1 <- (1:9)*3 
print(v1)
print(v1[4])
```

```{r}
v1 <- letters[1:7]
print(paste0("This letter is ", v1)) # paste0 concatenates strings
```

Question: How would you say "Letter 1 is a", "Letter 2 is b", etc. 
---
## Creating a matrix
```{r}
v1 <- 1:9
m1 <- matrix(v1, nrow = 3, byrow = T)
m2 <- cbind(v1 = 1:3, v2 = 1:3, v3 = 0:0)
print(m1)
print(m2)
```
---

## Accessing elements in a matrix
```{r}
m2 <- cbind(v1 = 1:3, v2 = 1:3, v3 = 0:0)
print(m2)
print("first row:")
print(m2[1, ])
print("second column")
print(m2[, 2])
print("access by column name")
print(m2[, "v2"])
```

Question: Create a 3 row, 4 column matrix, where the first column is (1, 2, 3), second column is (4, 5, 6 ) etc. 

---
## Lists
Lists can mix object of different types. 

```{r}
l <- list("a", 1, 0.5, TRUE)
print(l)
print(str(l)) # structure of l
```

---
## Lists
Lists can also be nested.
```{r}
l1 <- list("a", 1, 0.5, TRUE)
l2 <- list(l1, "test", matrix(1:9, nrow = 3)) ## first element of l2 is a list.
print(l2)
```
Question: what is the length of l1? what is the length of each element of l1? (use `length` function)
---
## Accessing elements in lists
Use double brackets `[[  ]]` to access elements in lists. 
```{r}
l1 <- list("a", 1, 0.5, TRUE)
l2 <- list(l1, "test", matrix(1:9, nrow = 3)) ## first element of l2 is a list.
print(l2[[1]])
print(l2[[2]])
print(l2[[3]])
```

Question: The first element of l2 is a list. Access this first element from l2, then the 4th element from l1. 

---
## Data frames
We will use data frames OFTEN. Data frames are really tables, but they are stored in R as lists, with the following conditions.
- Each element in the list represents a column.
- Each element in the list is an atomic vector.
- The length of each vector is the same (the number of rows)

```{r}
m1 <- cbind(1:3, letters[1:3])
print(m1) # a matrix cannot hold multiple data types. 
print(class(m1))
```
```{r}
df <- data.frame(numbers = 1:3, abc = letters[1:3])
print(df) # a data frame CAN hold multiple data types. 
print(class(df))
```

---
## Useful functions
- `print`
- You can print just about anything, but as a generic function, `print` works differently for different types of objects.
```{r}
a <- "test"
df <- data.frame(numbers = 1:3, abc = letters[1:3])
print(a) # a data frame CAN hold multiple data types. 
print(df)
```
```{r}
methods(print) ## all the different ways to print...
```
---
## Examining objects
- `ls`, `class`, `str`
```{r}
a <- "test"
df <- data.frame(numbers = 1:3, abc = letters[1:3])
ls() ## list objects in global environemtn
```
```{r}
class(df) ## class
```

```{r}
str(df) ## structure
```

---
## Sampling
- Sample without replacement
```{r}
set.seed(1234) ## set a random seed
v <- 1:100
s <- sample(v, 50)
print(s)
print(sort(s))
```

- Sample with replacement
```{r}
s2 <- sample(v, 50, replace = T)
print(sort(s2))
```

---
## Does S2 have duplicates?
```{r}
s2_unique <- unique(s2)
print(length(s2))
print(length(s2_unique))

print(length(s2) == length(s2_unique))
```


---
## In-class exercise

- Create the following:
  - `a`: a random vector of integers with 10 elements drawn from 1-20:
    - Use the `sample` function with `set.seed(10)`
    - Name the elements of `a` with a vector of names starting with "V1" and ending with "V10". 
      - Use the `paste0` function to create those names.
      - Create the identical vector of names using the `paste` function.
  - `b`: Using `a` as an index to select from `letters`
  - `d`: Use `rnorm` with a mean = 100 and an sd of 20
    - Use `?rnorm` to see the help guide.
  - Why did I skip `c`? 
  - Create a list `l` from `a`, `b`, `d`. 
    - Assign the names of the vectors in `l` to the `l`'s elements

---

## 2-d structures

- Create the following:
  - `m`: a matrix with three integer columns named "V1", "V2", "V3"
    - Create each column first as its own vector, then combine
    - `V1` = 1:10
    - `V2` is a random sample between 1:100
    - `V3` is drawn from a random uniform distribution between 0 and 50     - Use the same `set.seed(50)` as before
    - Inspect the `str` and `class` of `m`
  - `dat`, a data.frame built from `V1`, `V2`, `V3`, and `V4`
    - `V4` is a random selection of the letters A-E

---

## Functions
### Components

```{r, eval=FALSE}
function_name <- function(arg1, arg2 = 1:10, 
                          arg3 = ifelse(arg2 == 2, TRUE, FALSE)) {
  body
}
```

Three components of a function:
- `formals()`: arguments
- `body()`, the code, which returns the last object generated, unless specified with `return(x)`.
- `environment()`, function finds the values

Unnamed functions are **anonymous** functions. (Used in `*apply`)

---
Using `x` in a function does not change its global value.
```{r}
x <- 1:10
myfun <- function() {
  x * 10
}
myfun()

myfun <- function(x) {
  x <- x * 10
  return(x)
}
x <- 10
myfun(x = 20)
x
```

---
Each time you run `myfun`, a new function environment is created.
```{r}
myfun <- function(x) {
  x <- x * 10
  print(environment())
  return(x)
}
myfun(x)
myfun(x)
```

---
## Global assignment.
Use `<<-` to change value of global variable within a function.


```{r, message=FALSE}
a <- 10
myfun <- function(x) {
  a <<- x * 10   ## note <<- instead of <- 
  return(a)
}
myfun(5)
print(a)
```
---
## Useful functions

- `which` finds indices where a condition is true.

```{r, message=FALSE}
v <- 10:15
print(v)
a <- which(v %% 3 == 0) ## subset to elements divisible by 3
print(a) ## shows indices where condition is true.
```

---
## Useful functions
- `which.min` finds index of min value

```{r, message=FALSE}
v <- sample(1:20, 10)
print(v)
print(which.min(v)) # index of min value
print(which.max(v)) # index of max value
```



---
## data.frame vs data.table vs. tibble
- all 2D structures.
- data.frame = Base R
- tibble = `tidyverse`
- data.table = fast.

For now, we'll stick to data.frame
---

## data.frame indexing

- `data.frame` uses the following to subset: `[*row conditions, *column conditions]`

```{r, message=FALSE}
df <- data.frame(v1 = 1:5, v2 = 6:10)
rownames(df) <- LETTERS[1:5]
print(df)
```

---

## data.frame indexing

- Index using names. 
- Empty index `[  ,  'v2]` means "keep all rows"
```{r, message=FALSE}
df[,'v2'] ## column indexing
df[c("A", "B", "D"), ] ## row indexing
```
---
## data.frame subset

- Logical subset 
```{r, message=FALSE}
df[df$v1 > 3, ] ## get observations (rows) where first column is larger than 3
```

---
## Control structures
### Branching

- Pay attention to `{ }` placement
```{r}
a <- 5
if(a > 10) {
  print("Greater than 10!")
} else {
  print("Less than or equal to 10")
}
```

---
### Looping
```{r}
b <- 1:3
for(i in b) print(i)
```

```{r}
b <- 1:5
a <- 2
for(i in b){
  a <- 2 * a
  print(a)
}
```
---

### *apply
- A special form of looping
- Intended for *applying* a function to data. Uses *anonymous* function.
- 3 main kinds: `sapply`, `lapply`, `apply`


---
### `sapply`
- `sapply` iterates over input and returns a vector.
```{r}
v <- 1:10
sapply(v, function(x) x + 10) ## adds 10 to each element in v.
```
Use `{ }` for more complicated functions. BUT be careful with order of `{ }`, `( )`
```{r}
v1 <- 1:10
v2 <- sapply(v1, function(x){
  y <- x^2 
  return(y)
}) #
print(v2)
```
---
### `sapply`
If you don't specify `return`, the last object created will be returned.
```{r}
v1 <- 1:10
v2 <- sapply(v1, function(x){
  y <- x^2  ## y will be returned
}) #
print(v2)
```
---

### `lapply`
- Similar to `sapply`, except final object is returned as `list`.
- Useful if you need to store more complex objects (data.frame, plot, raster etc.)

```{r}
v1 <- 1:10
v2 <- lapply(v1, function(x){
  y <- x^2  ## y will be returned
}) #
print(v2)
```
---

### `apply`
- `apply` works well for 2D data, when you want to apply function over a row or column. 

```{r}
v1 <- sample(1:100, 10)
v2 <- sample(1:100, 10)
DF <- data.frame(v1, v2) ## data frame columns will take names of vectors
DF
```
---

Use `apply` to get column max value. The index 2 means "apply function to columns".

```{r}
colMax <- apply(DF, 2, FUN = max)
colMax
```

---

Use `apply` to get row max value. The index 1 means "apply function to rows".

```{r}
rowMax <- apply(DF, 1, FUN = max)
rowMax
```

We can use `apply` or `sapply` to create a new column in a data frame. 
```{r}
DF$rowMax <- apply(DF, 1, FUN = max)
DF
```
