<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Geospatial Analysis with R</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.19/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/lucy.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/middlebury-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="themes/class9.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Geospatial Analysis with R
]
.subtitle[
## Class 9
]

---



```r
library(sf)
library(dplyr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
data(world.cities, package = "maps")

world &lt;- ne_countries(scale = "medium", returnclass = "sf")
afr_capitals &lt;- world.cities %&gt;% filter(capital == 1) %&gt;% 
  st_as_sf(coords = c("long", "lat"), crs = 4326) %&gt;% 
  st_intersection(., world %&gt;% filter(continent == "Africa"))
p &lt;- world %&gt;% filter(continent == "Africa") %&gt;% 
  ggplot() + geom_sf(aes(fill = name), lwd = 0.2) + 
  geom_sf(data = afr_capitals, col = "blue", size = 0.5) + 
  scale_fill_grey(guide = FALSE) + theme_minimal()
ggsave(here::here("external/slides/figures/africa_capitals.png"), 
       width = 5, height = 4, dpi = 300, bg = "transparent")
```

---

## Functions
### Components


```r
function_name &lt;- function(arg1, arg2 = 1:10, 
                          arg3 = ifelse(arg2 == 2, TRUE, FALSE)) {
  body
}
```

Three components of a function:
- `formals()`: arguments
- `body()`, the code, which returns the last object generated, unless specified with `return(x)`.
- `environment()`, function finds the values

Unnamed functions are **anonymous** functions. (Used in `*apply`)

---

Using `x` in a function does not change its global value.

```r
x &lt;- 1:10
myfun &lt;- function() {
  x * 10
}
myfun()
```

```
##  [1]  10  20  30  40  50  60  70  80  90 100
```

```r
myfun &lt;- function(x) {
  x &lt;- x * 10
  return(x)
}
x &lt;- 10
myfun(x = 20)
```

```
## [1] 200
```

```r
x
```

```
## [1] 10
```

---
Each time you run `myfun`, a new function environment is created.

```r
myfun &lt;- function(x) {
  x &lt;- x * 10
  print(environment())
  return(x)
}
myfun(x)
```

```
## &lt;environment: 0x7fef9e6eedc0&gt;
```

```
## [1] 100
```

```r
myfun(x)
```

```
## &lt;environment: 0x7fef9e698ce0&gt;
```

```
## [1] 100
```

---
## Global assignment.
Use `&lt;&lt;-` to change value of global variable within a function.



```r
a &lt;- 10
myfun &lt;- function(x) {
  a &lt;&lt;- x * 10   ## note &lt;&lt;- instead of &lt;- 
  return(a)
}
myfun(5)
```

```
## [1] 50
```

```r
print(a)
```

```
## [1] 50
```

---


```r
library(dplyr)
search()
```

```
##  [1] ".GlobalEnv"        "package:dplyr"     "package:terra"    
##  [4] "tools:rstudio"     "package:stats"     "package:graphics" 
##  [7] "package:grDevices" "package:utils"     "package:datasets" 
## [10] "package:methods"   "Autoloads"         "package:base"
```

```r
set.seed(1)
v &lt;- 1:100 + runif(100, -10, 10)
f &lt;- filter(v, rep(1 / 5, 5))
```

```
## Error in UseMethod("filter"): no applicable method for 'filter' applied to an object of class "c('double', 'numeric')"
```

---

```r
detach("package:dplyr", unload = TRUE)
search()
```

```
##  [1] ".GlobalEnv"        "package:terra"     "tools:rstudio"    
##  [4] "package:stats"     "package:graphics"  "package:grDevices"
##  [7] "package:utils"     "package:datasets"  "package:methods"  
## [10] "Autoloads"         "package:base"
```

```r
f &lt;- filter(v, rep(1 / 5, 5))
plot(1:100, v, type = "l")
lines(1:100, f, col = "red")
```

&lt;img src="/Users/lestes/Dropbox/teaching/geog246346/geospaar/docs/class9_files/figure-html/unnamed-chunk-7-1.png" width="50%" style="display: block; margin: auto;" /&gt;


---
## Useful functions

- `which` finds indices where a condition is true.


```r
v &lt;- 10:15
print(v)
```

```
## [1] 10 11 12 13 14 15
```

```r
a &lt;- which(v %% 3 == 0) ## subset to elements divisible by 3
print(a) ## shows indices where condition is true.
```

```
## [1] 3 6
```

---
## Useful functions
- `which.min` finds index of min value


```r
v &lt;- sample(1:20, 10)
print(v)
```

```
##  [1] 12 16  1 13  5 15  6 18  9  7
```

```r
print(which.min(v)) # index of min value
```

```
## [1] 3
```

```r
print(which.max(v)) # index of max value
```

```
## [1] 8
```

---
## data.frame vs data.table vs. tibble
- all 2D structures.
- data.frame = Base R
- tibble = `tidyverse`
- data.table = fast.

For now, we'll stick to data.frame
---

## data.frame indexing

- `data.frame` uses the following to subset: `[*row conditions, *column conditions]`


```r
df &lt;- data.frame(v1 = 1:5, v2 = 6:10)
rownames(df) &lt;- LETTERS[1:5]
print(df)
```

```
##   v1 v2
## A  1  6
## B  2  7
## C  3  8
## D  4  9
## E  5 10
```

---

## data.frame indexing

- Index using names. 
- Empty index `[  ,  'v2]` means "keep all rows"

```r
df[,'v2'] ## column indexing
```

```
## [1]  6  7  8  9 10
```

```r
df[c("A", "B", "D"), ] ## row indexing
```

```
##   v1 v2
## A  1  6
## B  2  7
## D  4  9
```
---
## data.frame subset

- Logical subset 

```r
df[df$v1 &gt; 3, ] ## get observations (rows) where first column is larger than 3
```

```
##   v1 v2
## D  4  9
## E  5 10
```

---
## Control structures
### Branching

- Pay attention to `{ }` placement

```r
a &lt;- 5
if(a &gt; 10) {
  print("Greater than 10!")
} else {
  print("Less than or equal to 10")
}
```

```
## [1] "Less than or equal to 10"
```

---
### Looping

```r
b &lt;- 1:3
for(i in b) print(i)
```

```
## [1] 1
## [1] 2
## [1] 3
```


```r
b &lt;- 1:5
a &lt;- 2
for(i in b){
  a &lt;- 2 * a
  print(a)
}
```

```
## [1] 4
## [1] 8
## [1] 16
## [1] 32
## [1] 64
```
---

### *apply
- A special form of looping
- Intended for *applying* a function to data. Uses *anonymous* function.
- 3 main kinds: `sapply`, `lapply`, `apply`


---
### `sapply`
- `sapply` iterates over input and returns a vector.

```r
v &lt;- 1:10
sapply(v, function(x) x + 10) ## adds 10 to each element in v.
```

```
##  [1] 11 12 13 14 15 16 17 18 19 20
```
Use `{ }` for more complicated functions. BUT be careful with order of `{ }`, `( )`

```r
v1 &lt;- 1:10
v2 &lt;- sapply(v1, function(x){
  y &lt;- x^2 
  return(y)
}) #
print(v2)
```

```
##  [1]   1   4   9  16  25  36  49  64  81 100
```
---
### `sapply`
If you don't specify `return`, the last object created will be returned.

```r
v1 &lt;- 1:10
v2 &lt;- sapply(v1, function(x){
  y &lt;- x^2  ## y will be returned
}) #
print(v2)
```

```
##  [1]   1   4   9  16  25  36  49  64  81 100
```
---

### `lapply`
- Similar to `sapply`, except final object is returned as `list`.
- Useful if you need to store more complex objects (data.frame, plot, raster etc.)


```r
v1 &lt;- 1:10
v2 &lt;- lapply(v1, function(x){
  y &lt;- x^2  ## y will be returned
}) #
print(v2)
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 9
## 
## [[4]]
## [1] 16
## 
## [[5]]
## [1] 25
## 
## [[6]]
## [1] 36
## 
## [[7]]
## [1] 49
## 
## [[8]]
## [1] 64
## 
## [[9]]
## [1] 81
## 
## [[10]]
## [1] 100
```
---

### `apply`
- `apply` works well for 2D data, when you want to apply function over a row or column. 


```r
v1 &lt;- sample(1:100, 10)
v2 &lt;- sample(1:100, 10)
DF &lt;- data.frame(v1, v2) ## data frame columns will take names of vectors
DF
```

```
##    v1 v2
## 1  87  1
## 2  83 43
## 3  90 59
## 4  48 26
## 5  64 15
## 6  94 58
## 7  60 29
## 8  51 24
## 9  34 42
## 10 10 48
```
---

Use `apply` to get column max value. The index 2 means "apply function to columns".


```r
colMax &lt;- apply(DF, 2, FUN = max)
colMax
```

```
## v1 v2 
## 94 59
```

---

Use `apply` to get row max value. The index 1 means "apply function to rows".


```r
rowMax &lt;- apply(DF, 1, FUN = max)
rowMax
```

```
##  [1] 87 83 90 48 64 94 60 51 42 48
```

We can use `apply` or `sapply` to create a new column in a data frame. 

```r
DF$rowMax &lt;- apply(DF, 1, FUN = max)
DF
```

```
##    v1 v2 rowMax
## 1  87  1     87
## 2  83 43     83
## 3  90 59     90
## 4  48 26     48
## 5  64 15     64
## 6  94 58     94
## 7  60 29     60
## 8  51 24     51
## 9  34 42     42
## 10 10 48     48
```

## Data generation

Create the following:
- `dat`, a data.frame built from `V1`, `V2`, `V3`, and `V4`, where:
  - `V1` = 1:20
  - `V2` is a random sample between 1:100
  - `V3` is drawn from a random uniform distribution between 0 and 50     
  - `V4` is a random selection of the letters A-E
  - Use `set.seed(50)`
- Do this all at once (i.e. wrap the creation of V1-V4 in the `data.frame` call, precede it with `set.seed()`)

---

## Exercises

- Use a `for` to iterate over each row of `dat` and calculate it's `sum`
- Do the same with `lapply` and `sapply`
- Do the same using `rowSums`
- Select rows from `dat` containing the letter "E" in `V4`, and take the mean of values from the result in column `V3`





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
