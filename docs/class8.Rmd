---
title: "Geospatial Analysis with R"
subtitle: Class 8
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "lucy", "middlebury-fonts", "themes/class8.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, eval=FALSE}
library(sf)
library(dplyr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
data(world.cities, package = "maps")

world <- ne_countries(scale = "medium", returnclass = "sf")
afr_capitals <- world.cities %>% filter(capital == 1) %>% 
  st_as_sf(coords = c("long", "lat"), crs = 4326) %>% 
  st_intersection(., world %>% filter(continent == "Africa"))
p <- world %>% filter(continent == "Africa") %>% 
  ggplot() + geom_sf(aes(fill = name), lwd = 0.2) + 
  geom_sf(data = afr_capitals, col = "blue", size = 0.5) + 
  scale_fill_grey(guide = FALSE) + theme_minimal()
ggsave(here::here("external/slides/figures/africa_capitals.png"), 
       width = 5, height = 4, dpi = 300, bg = "transparent")
```

---

```{r, eval=FALSE}
library(stars)
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
x <- read_stars(tif)
plot(x, axes = TRUE)
plot(x[, , , 4:2], axes = TRUE)

s3url <- glue::glue("/vsis3/africa-fieldboundary-labels/",
                    "tiles_prod/cat2/992155_2023-06/",
                    "image.tif")  # not accessible
p <- read_stars(s3url, proxy = TRUE)
plot(p, rgb = 4:2)
plot(p, rgb = 3:1)
plot(p[, , , 1:3])
```

See [here](https://r-spatial.github.io/stars/articles/stars1.html) for more details.


---
```{r, echo = FALSE, fig.align='center'}
d <- "q1 q2 q3
0.666666667	1	1
1	0	0
0.666666667	1	1
1	1	1
0	1	0
1	1	0
0	1	0
0	0	0
0	0	1
0	0	0
1	1	0
0.25	0	1
0.666666667	0	1
1	0	1
0	0	1
1	1	1
1	0	1
1	0	0
1	1	1
0	1	1
1	1	0
0.333333333	1	0
0	1	1
0.333333333	1	1
0	0	1
1	0	1
0	0	0"
d <- read.table(text = d, header = TRUE)
par(mfrow = c(2, 2))
for(i in 1:3) {
  hist(d[, i], main = paste0("Q", i), ylim = c(0, 30), xlab = "", las = 2, 
       ylab = "", col = c("red", "purple", "orange")[i])
}
hist(rowSums(d), main = "Total", ylim = c(0, 30), xlab = "", las = 2, 
     ylab = "", col = "blue")
mtext(side = 1, "Score", outer = TRUE, line = -2)
mtext(side = 2, "N", outer = TRUE, line = -2)
```
---
# Programming tip

- Whenever possible, let the computer do your counting for you:
```{r}
a <- 1:1001
a[length(a)]
```
- Rather than 
```{r}
a[1001]
```
- Imagine this case:
```{r}
set.seed(1)
b <- 1:sample(1:10000, 1)
b[length(b)]
```

---

## Useful functions
- `print`
- You can print just about anything, but as a generic function, `print` works differently for different types of objects.
```{r}
a <- "test"
df <- data.frame(numbers = 1:3, abc = letters[1:3])
print(a) # a data frame CAN hold multiple data types. 
print(df)
```
---
```{r}
methods(print) ## all the different ways to print...
```
---
## Examining objects
- `ls`, `class`, `str`
```{r}
a <- "test"
df <- data.frame(numbers = 1:3, abc = letters[1:3])
ls() ## list objects in global environemtn
```
```{r}
class(df) ## class
```

```{r}
str(df) ## structure
```

---
## Sampling
- Sample without replacement
```{r}
set.seed(1234) ## set a random seed
v <- 1:100
s <- sample(v, 50)
print(s)
print(sort(s))
```

- Sample with replacement
```{r}
s2 <- sample(v, 50, replace = T)
print(sort(s2))
```

---
## Does S2 have duplicates?
```{r}
s2_unique <- unique(s2)
print(length(s2))
print(length(s2_unique))

print(length(s2) == length(s2_unique))
```


---
## In-class exercise

- Create the following:
  - `a`: a random vector of integers with 10 elements drawn from 1-20:
    - Use the `sample` function with `set.seed(10)`
    - Name the elements of `a` with a vector of names starting with "V1" and ending with "V10". 
      - Use the `paste0` function to create those names.
      - Create the identical vector of names using the `paste` function.
  - `b`: Using `a` as an index to select from `letters`
  - `d`: Use `rnorm` with a mean = 100 and an sd of 20
    - Use `?rnorm` to see the help guide.
  - Why did I skip `c`? 
  - Create a list `l` from `a`, `b`, `d`. 
    - Assign the names of the vectors in `l` to the `l`'s elements

---

## 2-d structures

- Create the following:
  - `m`: a matrix with three integer columns named "V1", "V2", "V3"
    - Create each column first as its own vector, then combine
    - `V1` = 1:10
    - `V2` is a random sample between 1:100
    - `V3` is drawn from a random uniform distribution between 0 and 50     - Use the same `set.seed(50)` as before
    - Inspect the `str` and `class` of `m`
  - `dat`, a data.frame built from `V1`, `V2`, `V3`, and `V4`
    - `V4` is a random selection of the letters A-E

---

## Functions
### Components

```{r, eval=FALSE}
function_name <- function(arg1, arg2 = 1:10, 
                          arg3 = ifelse(arg2 == 2, TRUE, FALSE)) {
  body
}
```

Three components of a function:
- `formals()`: arguments
- `body()`, the code, which returns the last object generated, unless specified with `return(x)`.
- `environment()`, function finds the values

Unnamed functions are **anonymous** functions. (Used in `*apply`)

---
Using `x` in a function does not change its global value.
```{r}
x <- 1:10
myfun <- function() {
  x * 10
}
myfun()

myfun <- function(x) {
  x <- x * 10
  return(x)
}
x <- 10
myfun(x = 20)
x
```

---
Each time you run `myfun`, a new function environment is created.
```{r}
myfun <- function(x) {
  x <- x * 10
  print(environment())
  return(x)
}
myfun(x)
myfun(x)
```

---
## Global assignment.
Use `<<-` to change value of global variable within a function.


```{r, message=FALSE}
a <- 10
myfun <- function(x) {
  a <<- x * 10   ## note <<- instead of <- 
  return(a)
}
myfun(5)
print(a)
```
---
## Useful functions

- `which` finds indices where a condition is true.

```{r, message=FALSE}
v <- 10:15
print(v)
a <- which(v %% 3 == 0) ## subset to elements divisible by 3
print(a) ## shows indices where condition is true.
```

---
## Useful functions
- `which.min` finds index of min value

```{r, message=FALSE}
v <- sample(1:20, 10)
print(v)
print(which.min(v)) # index of min value
print(which.max(v)) # index of max value
```

---
## data.frame vs data.table vs. tibble
- all 2D structures.
- data.frame = Base R
- tibble = `tidyverse`
- data.table = fast.

For now, we'll stick to data.frame
---

## data.frame indexing

- `data.frame` uses the following to subset: `[*row conditions, *column conditions]`

```{r, message=FALSE}
df <- data.frame(v1 = 1:5, v2 = 6:10)
rownames(df) <- LETTERS[1:5]
print(df)
```

---

## data.frame indexing

- Index using names. 
- Empty index `[  ,  'v2]` means "keep all rows"
```{r, message=FALSE}
df[,'v2'] ## column indexing
df[c("A", "B", "D"), ] ## row indexing
```
---
## data.frame subset

- Logical subset 
```{r, message=FALSE}
df[df$v1 > 3, ] ## get observations (rows) where first column is larger than 3
```

---
## Control structures
### Branching

- Pay attention to `{ }` placement
```{r}
a <- 5
if(a > 10) {
  print("Greater than 10!")
} else {
  print("Less than or equal to 10")
}
```

---
### Looping
```{r}
b <- 1:3
for(i in b) print(i)
```

```{r}
b <- 1:5
a <- 2
for(i in b){
  a <- 2 * a
  print(a)
}
```
---

### *apply
- A special form of looping
- Intended for *applying* a function to data. Uses *anonymous* function.
- 3 main kinds: `sapply`, `lapply`, `apply`


---
### `sapply`
- `sapply` iterates over input and returns a vector.
```{r}
v <- 1:10
sapply(v, function(x) x + 10) ## adds 10 to each element in v.
```
Use `{ }` for more complicated functions. BUT be careful with order of `{ }`, `( )`
```{r}
v1 <- 1:10
v2 <- sapply(v1, function(x){
  y <- x^2 
  return(y)
}) #
print(v2)
```
---
### `sapply`
If you don't specify `return`, the last object created will be returned.
```{r}
v1 <- 1:10
v2 <- sapply(v1, function(x){
  y <- x^2  ## y will be returned
}) #
print(v2)
```
---

### `lapply`
- Similar to `sapply`, except final object is returned as `list`.
- Useful if you need to store more complex objects (data.frame, plot, raster etc.)

```{r}
v1 <- 1:10
v2 <- lapply(v1, function(x){
  y <- x^2  ## y will be returned
}) #
print(v2)
```
---

### `apply`
- `apply` works well for 2D data, when you want to apply function over a row or column. 

```{r}
v1 <- sample(1:100, 10)
v2 <- sample(1:100, 10)
DF <- data.frame(v1, v2) ## data frame columns will take names of vectors
DF
```
---

Use `apply` to get column max value. The index 2 means "apply function to columns".

```{r}
colMax <- apply(DF, 2, FUN = max)
colMax
```

---

Use `apply` to get row max value. The index 1 means "apply function to rows".

```{r}
rowMax <- apply(DF, 1, FUN = max)
rowMax
```

We can use `apply` or `sapply` to create a new column in a data frame. 
```{r}
DF$rowMax <- apply(DF, 1, FUN = max)
DF
```
